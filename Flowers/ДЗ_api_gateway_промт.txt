Домашнее задание:
"Backend for frontends. Apigateway

Цель:
В этом ДЗ вы научитесь добавлять в приложение аутентификацию и регистрацию пользователей.


Описание/Пошаговая инструкция выполнения домашнего задания:
Вариант 1 (С КОДОМ)

Добавить в приложение аутентификацию и регистрацию пользователей.


Реализовать сценарий "Изменение и просмотр данных в профиле клиента".

Пользователь регистрируется. Заходит под собой и по определенному урлу получает данные о своем профиле. Может поменять данные в профиле. Данные профиля для чтения и редактирования не должны быть доступны другим клиентам (аутентифицированным или нет).


На выходе должны быть

0) описание архитектурного решения и схема взаимодействия сервисов (в виде картинки)

1) команда установки приложения (из helm-а или из манифестов). Обязательно указать в каком namespace нужно устанавливать.

команда установки api-gateway, если он отличен от nginx-ingress.
тесты постмана, которые прогоняют сценарий:
регистрация пользователя 1
проверка, что изменение и получение профиля пользователя недоступно без логина
вход пользователя 1
изменение профиля пользователя 1
проверка, что профиль поменялся
выход* (если есть)
регистрация пользователя 2
вход пользователя 2
проверка, что пользователь2 не имеет доступа на чтение и редактирование профиля пользователя1.

В тестах обязательно

наличие {{baseUrl}} для урла
использование домена arch.homework в качестве initial значения {{baseUrl}}
использование сгенерированных случайно данных в сценарии
отображение данных запроса и данных ответа при запуске из командной строки с помощью newman."

=============================================================================================

Вот мой ASP.NET Web API:

Program.cs:
using Flowers.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Flowers.Models;
using Prometheus;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();

// Загрузка конфигурации из /app/config
if (File.Exists("/app/config/appsettings.json"))
{
    builder.Configuration.AddJsonFile("/app/config/appsettings.json", optional: false, reloadOnChange: true);
}

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

// Configure DbContext with PostgreSQL
builder.Services.AddDbContext<AppDbContext>(options =>
{
    options.UseNpgsql(connectionString, options =>
    {
        options.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(5),
            errorCodesToAdd: null);
    });
    options.LogTo(Console.WriteLine, LogLevel.Information);
});

// Add health checks
builder.Services.AddHealthChecks()
    .AddCheck<DbHealthCheck>("Database")
    .AddCheck("Self", () => HealthCheckResult.Healthy("API is healthy"));

// Регистрируем наш кастомный health check как Scoped
builder.Services.AddScoped<DbHealthCheck>();

// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

app.UseCors(builder => builder.AllowAnyOrigin());

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

//app.UseHttpsRedirection();
//app.UseAuthorization();

// Корневой endpoint
app.MapGet("/", () => "Flowers API is running");

// User endpoints group
var userGroup = app.MapGroup("/user");

// Получение всех пользователей
userGroup.MapGet("/", async (AppDbContext context) =>
{
    var users = await context.Users.ToListAsync();
    return Results.Ok(users);
});

// Создание пользователя
userGroup.MapPost("/", async (User user, AppDbContext context) =>
{
    context.Users.Add(user);
    await context.SaveChangesAsync();
    return Results.Created($"/user/{user.Id}", user);
});

// Получение пользователя по ID
userGroup.MapGet("/{userId:long}", async (long userId, AppDbContext context) =>
{
    var user = await context.Users.FindAsync(userId);
    return user is null ? Results.NotFound() : Results.Ok(user);
});

// Обновление пользователя
userGroup.MapPut("/{userId:long}", async (long userId, User updatedUser, AppDbContext context) =>
{
    var user = await context.Users.FindAsync(userId);
    if (user is null) return Results.NotFound();

    if (updatedUser.Username != null) user.Username = updatedUser.Username;
    if (updatedUser.FirstName != null) user.FirstName = updatedUser.FirstName;
    if (updatedUser.LastName != null) user.LastName = updatedUser.LastName;
    if (updatedUser.Email != null) user.Email = updatedUser.Email;
    if (updatedUser.Phone != null) user.Phone = updatedUser.Phone;

    await context.SaveChangesAsync();
    return Results.Ok(user);
});

// Удаление пользователя
userGroup.MapDelete("/{userId:long}", async (long userId, AppDbContext context) =>
{
    var user = await context.Users.FindAsync(userId);
    if (user is null) return Results.NotFound();

    context.Users.Remove(user);
    await context.SaveChangesAsync();
    return Results.NoContent();
});

// Health checks endpoints
app.MapHealthChecks("/health");
app.MapHealthChecks("/health/detailed", new HealthCheckOptions()
{
    ResponseWriter = async (context, report) =>
    {
        context.Response.ContentType = "application/json";
        var response = new
        {
            Status = report.Status.ToString(),
            Checks = report.Entries.Select(e => new
            {
                Component = e.Key,
                Status = e.Value.Status.ToString(),
                Description = e.Value.Description
            }),
            Duration = report.TotalDuration
        };
        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
});

app.Use(async (context, next) =>
{
    Console.WriteLine($"Received {context.Request.Method} {context.Request.Path}");
    await next();
});

app.UseHttpMetrics();
app.MapMetrics();
app.Run();

// Кастомная проверка здоровья БД
public class DbHealthCheck : IHealthCheck
{
    private readonly IServiceScopeFactory _scopeFactory;

    public DbHealthCheck(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        try
        {
            using var scope = _scopeFactory.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();

            await dbContext.Database.CanConnectAsync(cancellationToken);
            return HealthCheckResult.Healthy("Database is available");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database is unavailable", ex);
        }
    }
}

User.cs:

using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace Flowers.Models
{
    [Table("users")]  // Явное указание таблицы в нижнем регистре
    public class User
    {
        [Column("id")]  // Можно явно указать имена колонок
        public long Id { get; set; }

        [Column("username")]
        public required string Username { get; set; }

        [Column("firstname")]
        public required string FirstName { get; set; }

        [Column("lastname")]
        public required string LastName { get; set; }

        [Column("email")]
        public required string Email { get; set; }

        [Column("phone")]
        public required string Phone { get; set; }
    }
}

=============================================================================================

Вот скрипт установки приложения:"<#
.SYNOPSIS
  Полное развертывание инфраструктуры с проверкой таблицы users
#>

# 0. Переход в папку скрипта (совместимая версия)
if ($PSScriptRoot) {
    $scriptDir = $PSScriptRoot
} else {
    $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
}
Write-Host "Автоматический переход в папку скрипта: $scriptDir" -ForegroundColor DarkGray
Set-Location $scriptDir

# 1. Очистка
Write-Host "1. Очистка старых релизов..." -ForegroundColor Yellow
helm uninstall postgresql 2>$null
kubectl delete -f .\kubernetes-manifests\ --recursive 2>$null
kubectl delete pvc --all 2>$null

# 2. Применение манифестов
Write-Host "2. Применение манифестов..." -ForegroundColor Yellow
$manifests = @(
    ".\kubernetes-manifests\configmaps\",
    ".\kubernetes-manifests\secrets\",
    ".\kubernetes-manifests\deployments\",
    ".\kubernetes-manifests\services\",
    ".\kubernetes-manifests\ingress\"
)

foreach ($manifest in $manifests) {
    try {
        kubectl apply -f $manifest
    } catch {
        Write-Host "Ошибка при применении манифеста $manifest : $_" -ForegroundColor Yellow
    }
}
Write-Host "Применение манифестов завершено!" -ForegroundColor Green

# 3. Установка PostgreSQL
Write-Host "`n3. Установка PostgreSQL..." -ForegroundColor Cyan

helm repo add bitnami https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami
helm repo update

function Decode-Base64 {
    param([string]$encoded)
    [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded))
}

$POSTGRES_USER = Decode-Base64 (kubectl get secret db-secret -o jsonpath='{.data.POSTGRES_USER}')
$POSTGRES_PASSWORD = Decode-Base64 (kubectl get secret db-secret -o jsonpath='{.data.POSTGRES_PASSWORD}')
$POSTGRES_DB = Decode-Base64 (kubectl get secret db-secret -o jsonpath='{.data.POSTGRES_DB}')

helm upgrade --install postgresql bitnami/postgresql `
  --set global.postgresql.auth.postgresPassword=$POSTGRES_PASSWORD `
  --set global.postgresql.auth.username=$POSTGRES_USER `
  --set global.postgresql.auth.password=$POSTGRES_PASSWORD `
  --set global.postgresql.auth.database=$POSTGRES_DB `
  --set persistence.enabled=true `
  --set persistence.size=1Gi
  
# 4. Проверка и установка Ingress Nginx Controller
Write-Host "`n4. Проверка и установка Ingress Nginx Controller..." -ForegroundColor Cyan

# Проверяем, установлен ли уже ingress-nginx
$ingressInstalled = helm list -n ingress-nginx | findstr "ingress-nginx"

if (-not $ingressInstalled) {
    # Добавляем репозиторий (если еще не добавлен)
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx 2>$null
    helm repo update

    Write-Host "Установка Ingress Nginx Controller..." -ForegroundColor Yellow
    
    # Устанавливаем с явными параметрами и таймаутом
    $ingressJob = Start-Job -ScriptBlock {
        helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx `
            --namespace ingress-nginx `
            --create-namespace `
            --set controller.service.type=LoadBalancer `
            --set controller.ingressClassResource.default=true `
            --atomic `
            --timeout 5m
    }

    # Ожидание с прогресс-баром
    Write-Host "Ожидаем завершения установки (максимум 5 минут)..." -NoNewline
    $timeout = 180 # 3 минуты
    $startTime = Get-Date

    while ($ingressJob.State -eq "Running") {
        if (((Get-Date) - $startTime).TotalSeconds -gt $timeout) {
            Stop-Job $ingressJob
            Write-Host "`nТаймаут установки Ingress Controller!" -ForegroundColor Red
            exit 1
        }
        
        Write-Host "." -NoNewline
        Start-Sleep -Seconds 5
    }

    Receive-Job $ingressJob
    Remove-Job $ingressJob

    Write-Host "`nIngress Nginx Controller успешно установлен!" -ForegroundColor Green
} else {
    Write-Host "Ingress Nginx Controller уже установлен, пропускаем установку" -ForegroundColor Green
}

# 5. Ожидание БД
Write-Host "`n5. Ожидание БД..." -ForegroundColor Cyan
$timeout = 180
$startTime = Get-Date
$dbReady = $false

while (-not $dbReady) {
    try {
        $status = kubectl get pod -l app.kubernetes.io/name=postgresql -o json | ConvertFrom-Json
        if ($status.items.status.containerStatuses.ready -eq $true) {
            $dbReady = $true
			Write-Host "БД запущена!" -ForegroundColor Green
            break
        }
    } catch {
        # Продолжаем ожидать если команда не сработала
    }
    
    if (((Get-Date) - $startTime).TotalSeconds -gt $timeout) {
        Write-Host "Таймаут ожидания PostgreSQL!" -ForegroundColor Red
        exit 1
    }
    
    Start-Sleep -Seconds 5
    Write-Host "Ожидание..." -ForegroundColor Gray
}

# 6. Запуск job для миграции БД
Write-Host "`n6. Запуск job для миграции БД..." -ForegroundColor Cyan

# Применяем job
kubectl apply -f .\kubernetes-manifests\jobs\db-migration-job.yaml

# Ожидаем завершения job
Write-Host "Ожидаем завершения миграции..." -ForegroundColor Yellow
$timeout = 120
$startTime = Get-Date

while ($true) {
    $jobStatus = kubectl get job db-migration -o json | ConvertFrom-Json
    if ($jobStatus.status.succeeded -eq 1) {
        Write-Host "Миграция БД завершена!" -ForegroundColor Green
        break
    }
    elseif ($jobStatus.status.failed -gt 0) {
        Write-Host "Ошибка при выполнении миграции!" -ForegroundColor Red
        kubectl logs -l job-name=db-migration
        exit 1
    }
    
    if (((Get-Date) - $startTime).TotalSeconds -gt $timeout) {
        Write-Host "Таймаут ожидания миграции БД!" -ForegroundColor Red
        kubectl logs -l job-name=db-migration
        exit 1
    }
    
    Start-Sleep -Seconds 5
    Write-Host "." -NoNewline
}

# Выводим логи job
Write-Host "`nЛоги миграции:" -ForegroundColor Cyan
kubectl logs -l job-name=db-migration

# 7.2 Развертывание API
Write-Host "`n7.2. Развертывание flowers-api..." -ForegroundColor Green

# 7.3. Сборка образа
try {
    docker build -t flowers-api:latest .
    if (-not $?) {
        throw "Ошибка сборки Docker образа"
    }
} catch {
    Write-Host "Ошибка при сборке образа: $_" -ForegroundColor Red
    exit 1
}

# 8. Проверка запуска API и вывод логов
Write-Host "`n7. Проверка flowers-api и вывод логов..." -ForegroundColor Cyan
$timeout = 120
$startTime = Get-Date
$apiReady = $false
$logsChecked = $false

while (-not $apiReady) {
    try {
        $pod = kubectl get pod -l app=flowers-api -o json | ConvertFrom-Json
        $status = $pod.items.status
        
        if ($status.phase -eq "Running" -and $status.containerStatuses.ready -eq $true) {
            Write-Host "Pod запущен!" -ForegroundColor Green
            
            # Выводим логи API только один раз
            if (-not $logsChecked) {
                Write-Host "`nЛоги flowers-api:" -ForegroundColor Yellow
                $logs = kubectl logs -l app=flowers-api --tail=20
                $logs | ForEach-Object {
                    if ($_ -match "Now listening on:|Application started|Hosting environment|Content root path") {
                        Write-Host $_ -ForegroundColor Cyan
                    } else {
                        Write-Host $_
                    }
                }
                $logsChecked = $true
                
                # Дополнительная проверка ключевых сообщений
                if ($logs -notmatch "Application started") {
                    Write-Host "Предупреждение: API не отправил сообщение о старте приложения" -ForegroundColor Yellow
                }
            }
            
            $apiReady = $true
            break
        }
    } catch {
        # Продолжаем ожидать если команда не сработала
    }
    
    if (((Get-Date) - $startTime).TotalSeconds -gt $timeout) {
        Write-Host "Таймаут ожидания API!" -ForegroundColor Red
        Write-Host "Последние логи:" -ForegroundColor Red
        kubectl logs -l app=flowers-api --tail=50
        exit 1
    }
    
    Start-Sleep -Seconds 5
    Write-Host "Ожидание API..." -ForegroundColor Gray
}

# 9. Финальные проверки
Write-Host "`n8. Итоговый статус:" -ForegroundColor Green
kubectl get pods,svc,ingress

# 10. Проверка доступности API
Write-Host "`n9. Проверка доступности API..." -ForegroundColor Cyan
$ingressHost = kubectl get ingress -o jsonpath='{.items[0].spec.rules[0].host}'
$apiUrl = "http://$ingressHost/"

Write-Host "Выполняем тестовый запрос к API: $apiUrl" -ForegroundColor Yellow

try {
    $response = Invoke-WebRequest -Uri $apiUrl -Method Get -UseBasicParsing -TimeoutSec 10
    
    if ($response.StatusCode -eq 200) {
        Write-Host "API успешно отвечает! Результат:" -ForegroundColor Green
        Write-Host $response.Content -ForegroundColor DarkGray
    } else {
        Write-Host "API вернул неожиданный статус: $($response.StatusCode)" -ForegroundColor Yellow
        Write-Host "Ответ сервера:" -ForegroundColor DarkGray
        Write-Host $response.Content
    }
} catch {
    Write-Host "Ошибка при запросе к API:" -ForegroundColor Red
    Write-Host $_.Exception.Message -ForegroundColor Red
    
    # Дополнительная диагностика
    Write-Host "`nПроверка endpoints сервиса:" -ForegroundColor Yellow
    kubectl get endpoints
    
    Write-Host "`nПоследние логи API:" -ForegroundColor Yellow
    kubectl logs -l app=flowers-api --tail=20
}

Write-Host "`nГотово! Для ручной проверки выполните:" -ForegroundColor Green
Write-Host "curl $apiUrl" -ForegroundColor Cyan
Write-Host "или откройте в браузере: $apiUrl" -ForegroundColor Cyan

# 11. Развертывание Prometheus
Write-Host "`n11. Развертывание Prometheus" -ForegroundColor Cyan
try {
    # Запуск Prometheus
    docker run -d `
      --name prometheus `
      --hostname arch.homework `
      -p 9090:9090 `
      -v ${PWD}/prometheus.yml:/etc/prometheus/prometheus.yml `
      prom/prometheus

    # Проверка запуска контейнера
    $prometheusStatus = docker inspect -f '{{.State.Status}}' prometheus 2>$null
    if ($prometheusStatus -ne "running") {
        throw "Prometheus container failed to start"
    }

    Write-Host "Prometheus успешно запущен" -ForegroundColor Green
}
catch {
    Write-Host "Ошибка при запуске Prometheus: $_" -ForegroundColor Red
    exit 1
}

# Проверка метрик Prometheus
Write-Host "`nПроверка метрик Prometheus..." -ForegroundColor Cyan
try {
    $retryCount = 0
    $maxRetries = 5
    $success = $false
    
    while ($retryCount -lt $maxRetries -and -not $success) {
        try {
            $metrics = curl -v http://arch.homework:9090/metrics 2>&1
            if ($metrics -match "HTTP.*200") {
                Write-Host "Метрики Prometheus доступны" -ForegroundColor Green
                $success = $true
            } else {
                throw "Не удалось получить метрики"
            }
        }
        catch {
            $retryCount++
            if ($retryCount -ge $maxRetries) {
                throw
            }
            Start-Sleep -Seconds 5
        }
    }
}
catch {
    Write-Host "Ошибка при проверке метрик Prometheus: $_" -ForegroundColor Yellow
}

# 12. Развертывание Grafana
Write-Host "`n12. Развертывание Grafana" -ForegroundColor Cyan
try {
    # Запуск Grafana
    docker run -d `
      -p 3000:3000 `
      --name=grafana `
      grafana/grafana-enterprise

    # Проверка запуска контейнера
    $grafanaStatus = docker inspect -f '{{.State.Status}}' grafana 2>$null
    if ($grafanaStatus -ne "running") {
        throw "Grafana container failed to start"
    }

    Write-Host "Grafana успешно запущена" -ForegroundColor Green
}
catch {
    Write-Host "Ошибка при запуске Grafana: $_" -ForegroundColor Red
    exit 1
}

# 13. Создание общей сети и подключение контейнеров
Write-Host "`n13. Настройка сети monitoring" -ForegroundColor Cyan
try {
    # Создание сети (если не существует)
    $networkExists = docker network ls --filter name=monitoring --format '{{.Name}}'
    if (-not $networkExists) {
        docker network create monitoring
    }

    # Подключение контейнеров
    docker network connect monitoring prometheus
    docker network connect monitoring grafana

    Write-Host "Контейнеры подключены к сети monitoring" -ForegroundColor Green
    Write-Host "Адрес Prometheus для Grafana: http://prometheus:9090" -ForegroundColor Cyan
}
catch {
    Write-Host "Ошибка при настройке сети: $_" -ForegroundColor Red
}

# Проверка доступности Grafana
Write-Host "`nПроверка Grafana..." -ForegroundColor Cyan
try {
    $retryCount = 0
    $maxRetries = 10
    $success = $false
    
    while ($retryCount -lt $maxRetries -and -not $success) {
        try {
            $grafanaCheck = curl -v http://arch.homework:3000 2>&1
            if ($grafanaCheck -match "HTTP.*200") {
                Write-Host "Grafana доступна по адресу: http://arch.homework:3000" -ForegroundColor Green
                Write-Host "Логин/пароль по умолчанию: admin/admin" -ForegroundColor Cyan
                $success = $true
            } else {
                throw "Grafana не отвечает"
            }
        }
        catch {
            $retryCount++
            if ($retryCount -ge $maxRetries) {
                throw
            }
            Start-Sleep -Seconds 5
        }
    }
}
catch {
    Write-Host "Grafana не стала доступна после $maxRetries попыток" -ForegroundColor Yellow
}

# 14. Инструментирование БД экспортером для prometheus
Write-Host "`n14. Инструментирование БД экспортером для prometheus" -ForegroundColor Cyan
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install prometheus-postgresql prometheus-community/prometheus-postgres-exporter
helm repo list"

# 15. Установка и настройка Kong API Gateway
Write-Host "`n15. Установка Kong API Gateway..." -ForegroundColor Cyan

# Добавляем репозиторий Helm для Kong
helm repo add kong https://charts.konghq.com
helm repo update

# Создаем namespace для Kong
kubectl create namespace kong --dry-run=client -o yaml | kubectl apply -f -

Write-Host "Устанавливаем Kong Ingress Controller..." -ForegroundColor Yellow
helm upgrade --install kong kong/kong -n kong `
  --set ingressController.installCRDs=false `
  --set admin.enabled=true `
  --set admin.http.enabled=true `
  --set admin.type=ClusterIP `
  --set proxy.type=NodePort `
  --set proxy.http.enabled=true `
  --set proxy.tls.enabled=true

# Ждем запуска Kong
Write-Host "Ожидаем запуска Kong..." -ForegroundColor Yellow
$timeout = 120
$startTime = Get-Date
$kongReady = $false

while (-not $kongReady) {
    try {
        $kongStatus = kubectl get pods -n kong -l app.kubernetes.io/name=kong -o json | ConvertFrom-Json
        if ($kongStatus.items.status.containerStatuses.ready -eq $true -and $kongStatus.items.status.phase -eq "Running") {
            $kongReady = $true
            Write-Host "Kong успешно запущен!" -ForegroundColor Green
            break
        }
    } catch {
        # Продолжаем ожидать
    }
    
    if (((Get-Date) - $startTime).TotalSeconds -gt $timeout) {
        Write-Host "Таймаут ожидания Kong!" -ForegroundColor Red
        break
    }
    
    Start-Sleep -Seconds 5
    Write-Host "." -NoNewline
}

# Получаем NodePort порт Kong
Write-Host "`nПолучаем адрес Kong Gateway..." -ForegroundColor Cyan
$kongPort = kubectl get svc -n kong kong-kong-proxy -o jsonpath='{.spec.ports[0].nodePort}'
Write-Host "Kong NodePort: $kongPort" -ForegroundColor Green

# Настраиваем port forwarding для Kong
Write-Host "Настраиваем port forwarding для Kong..." -ForegroundColor Cyan
$portForwardJob = Start-Job -ScriptBlock {
    kubectl port-forward -n kong svc/kong-kong-proxy 8080:80
}

# Ждем немного для установки port forwarding
Start-Sleep -Seconds 3

# Проверяем работу Kong через port forward
Write-Host "`nПроверяем работу Kong Gateway через port forward..." -ForegroundColor Cyan

# Определяем тестовый URL
$testUrl = "http://localhost:8080"

try {
    # Пытаемся достучаться до Kong
    $kongResponse = Invoke-WebRequest -Uri $testUrl -Method Get -UseBasicParsing -TimeoutSec 10
    
    # Если успешно (200 OK или другие 2xx), Kong полностью operational с маршрутом
    Write-Host "✅ Kong Gateway полностью operational!" -ForegroundColor Green
    Write-Host "   Статус: $($kongResponse.StatusCode)" -ForegroundColor Green
    if ($kongResponse.Headers["Server"] -like "*kong*") {
        Write-Host "   Обнаружен Kong server header: $($kongResponse.Headers['Server'])" -ForegroundColor Green
    }
    
} catch {
    # Обрабатываем исключения (которые часто включают 4xx и 5xx статусы)
    if ($_.Exception.Response -ne $null) {
        # Если исключение имеет response, это HTTP ошибка
        $statusCode = $_.Exception.Response.StatusCode.value__
        
        if ($statusCode -eq 404) {
            # 404 ожидаемо, когда маршруты не настроены
            Write-Host "✅ Kong Gateway работает и принимает запросы!" -ForegroundColor Green
            Write-Host "   Статус: 404 (Маршруты еще не настроены - это ожидаемо)" -ForegroundColor Yellow
            Write-Host "   Следующий шаг: Настройка маршрутов и сервисов для вашего API" -ForegroundColor Cyan
        } else {
            # Другие 4xx/5xx ошибки могут указывать на проблемы конфигурации
            Write-Host "⚠️  Kong ответил с неожиданной HTTP ошибкой:" -ForegroundColor Yellow
            Write-Host "   Статус: $statusCode" -ForegroundColor Yellow
            Write-Host "   Это может указывать на проблему с конфигурацией." -ForegroundColor Yellow
        }
    } else {
        # Нет HTTP response (сетевая ошибка, таймаут, отказ соединения)
        Write-Host "❌ Kong НЕ отвечает или недоступен:" -ForegroundColor Red
        Write-Host "   Ошибка: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "   Это указывает на серьезную проблему с установкой Kong или сетевой конфигурацией." -ForegroundColor Red
    }
}

# Создаем базовый маршрут для тестирования
Write-Host "`nСоздаем тестовый маршрут для Kong..." -ForegroundColor Cyan
$kongTestRoute = @"
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kong-test-route
  namespace: kong
  annotations:
    konghq.com/strip-path: "true"  # Другие Kong-специфичные аннотации остаются
spec:
  ingressClassName: kong  # ← Замена аннотации на это поле
  rules:
  - http:
      paths:
      - path: /test
        pathType: Prefix
        backend:
          service:
            name: kong-kong-proxy
            port:
              number: 80
"@

$kongTestRoute | kubectl apply -f -

# Выводим информацию о сервисах
Write-Host "`nТекущее состояние сервисов:" -ForegroundColor Green
kubectl get svc -n kong
kubectl get pods -n kong
kubectl get ingress -n kong

Write-Host "`nУстановка Kong завершена!" -ForegroundColor Green
Write-Host "Kong API Gateway работает и готов" -ForegroundColor Cyan
Write-Host "Доступ к Kong через port forward: http://localhost:8080" -ForegroundColor Cyan
Write-Host "Тестовый URL: http://localhost:8080" -ForegroundColor Cyan
Write-Host "Или прямой NodePort: http://localhost:$kongPort" -ForegroundColor Cyan
Write-Host "Следующие шаги:" -ForegroundColor Yellow
Write-Host "1. Настройте маршруты для ваших сервисов" -ForegroundColor Yellow
Write-Host "2. Настройте плагины аутентификации" -ForegroundColor Yellow
Write-Host "3. Настройте SSL/TLS при необходимости" -ForegroundColor Yellow

Write-Host "`nPort forward job работает в фоне. Для остановки используйте:" -ForegroundColor Gray
Write-Host "Stop-Job $($portForwardJob.Id)" -ForegroundColor Gray
Write-Host "Remove-Job $($portForwardJob.Id)" -ForegroundColor Gray

=============================================================================================

Результат выполнения скрипта:
"Windows PowerShell
(C) Корпорация Майкрософт (Microsoft Corporation). Все права защищены.

Попробуйте новую кроссплатформенную оболочку PowerShell (https://aka.ms/pscore6)

Автоматический переход в папку скрипта: C:\Users\User\source\repos\Flowers\Flowers
1. Очистка старых релизов...
No resources found
2. Применение манифестов...
configmap/flowers-config created
secret/db-secret created
deployment.apps/flowers-api created
service/flowers-service created
ingress.networking.k8s.io/flowers-ingress created
Применение манифестов завершено!

3. Установка PostgreSQL...
"bitnami" already exists with the same configuration, skipping
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "ingress-nginx" chart repository
...Successfully got an update from the "kong" chart repository
...Successfully got an update from the "prometheus-community" chart repository
...Successfully got an update from the "bitnami" chart repository
Update Complete. ⎈Happy Helming!⎈
Release "postgresql" does not exist. Installing it now.
NAME: postgresql
LAST DEPLOYED: Sun Sep  7 20:10:21 2025
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
CHART NAME: postgresql
CHART VERSION: 16.7.27
APP VERSION: 17.6.0

⚠ WARNING: Since August 28th, 2025, only a limited subset of images/charts are available for free.
    Subscribe to Bitnami Secure Images to receive continued support and security updates.
    More info at https://bitnami.com and https://github.com/bitnami/containers/issues/83267

** Please be patient while the chart is being deployed **

PostgreSQL can be accessed via port 5432 on the following DNS names from within your cluster:

    postgresql.default.svc.cluster.local - Read/Write connection

To get the password for "postgres" run:

    export POSTGRES_PASSWORD=$(kubectl get secret --namespace default postgresql -o jsonpath="{.data.postgres-password}" | base64 -d)

To connect to your database run the following command:

    kubectl run postgresql-client --rm --tty -i --restart='Never' --namespace default --image docker.io/bitnami/postgresql:17.6.0-debian-12-r4 --env="PGPASSWORD=$POSTGRES_PASSWORD" \
      --command -- psql --host postgresql -U postgres -d users_db -p 5432

    > NOTE: If you access the container using bash, make sure that you execute "/opt/bitnami/scripts/postgresql/entrypoint.sh /bin/bash" in order to avoid the error "psql: local user with ID 1001} does not exist"

To connect to your database from outside the cluster execute the following commands:

    kubectl port-forward --namespace default svc/postgresql 5432:5432 &
    PGPASSWORD="$POSTGRES_PASSWORD" psql --host 127.0.0.1 -U postgres -d users_db -p 5432

WARNING: The configured password will be ignored on new installation in case when previous PostgreSQL release was deleted through the helm command. In that case, old PVC will have an old password, and setting it through helm won't take effect. Deleting persistent volumes (PVs) will solve the issue.

WARNING: There are "resources" sections in the chart not set. Using "resourcesPreset" is not recommended for production. For production installations, please set the following values according to your workload needs:
  - primary.resources
  - readReplicas.resources
+info https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

4. Проверка и установка Ingress Nginx Controller...
"ingress-nginx" already exists with the same configuration, skipping
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "kong" chart repository
...Successfully got an update from the "ingress-nginx" chart repository
...Successfully got an update from the "prometheus-community" chart repository
...Successfully got an update from the "bitnami" chart repository
Update Complete. ⎈Happy Helming!⎈
Установка Ingress Nginx Controller...
Ожидаем завершения установки (максимум 5 минут)........Release "ingress-nginx" does not exist. Installing it now.
NAME: ingress-nginx
LAST DEPLOYED: Sun Sep  7 20:10:27 2025
NAMESPACE: ingress-nginx
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
The ingress-nginx controller has been installed.
It may take a few minutes for the load balancer IP to be available.
You can watch the status by running 'kubectl get service --namespace ingress-nginx ingress-nginx-controller --output wide --watch'

An example Ingress that makes use of the controller:
  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: example
    namespace: foo
  spec:
    ingressClassName: nginx
    rules:
      - host: www.example.com
        http:
          paths:
            - pathType: Prefix
              backend:
                service:
                  name: exampleService
                  port:
                    number: 80
              path: /
    # This section is only required if TLS is to be enabled for the Ingress
    tls:
      - hosts:
        - www.example.com
        secretName: example-tls

If TLS is enabled for the Ingress, a Secret containing the certificate and key must also be provided:

  apiVersion: v1
  kind: Secret
  metadata:
    name: example-tls
    namespace: foo
  data:
    tls.crt: <base64 encoded cert>
    tls.key: <base64 encoded key>
  type: kubernetes.io/tls

Ingress Nginx Controller успешно установлен!

5. Ожидание БД...
БД запущена!

6. Запуск job для миграции БД...
job.batch/db-migration created
Ожидаем завершения миграции...
.Миграция БД завершена!

Логи миграции:
 lastname  | character varying(255) |           | not null |                                   | extended |             |              |
 email     | character varying(255) |           | not null |                                   | extended |             |              |
 phone     | character varying(50)  |           | not null |                                   | extended |             |              |
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
    "users_username_key" UNIQUE CONSTRAINT, btree (username)
Access method: heap

Migration completed successfully!

7.2. Развертывание flowers-api...
[+] Building 4.8s (15/15) FINISHED                                                                 docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                               0.0s
 => => transferring dockerfile: 352B                                                                               0.0s
 => [internal] load metadata for mcr.microsoft.com/dotnet/sdk:8.0                                                  0.4s
 => [internal] load metadata for mcr.microsoft.com/dotnet/aspnet:8.0                                               0.4s
 => [internal] load .dockerignore                                                                                  0.0s
 => => transferring context: 2B                                                                                    0.0s
 => [build 1/6] FROM mcr.microsoft.com/dotnet/sdk:8.0@sha256:7fd287cec03e027e39be13fb06ca1347f1338c7a6ab4ad305d94  0.0s
 => => resolve mcr.microsoft.com/dotnet/sdk:8.0@sha256:7fd287cec03e027e39be13fb06ca1347f1338c7a6ab4ad305d94d91852  0.0s
 => [stage-1 1/3] FROM mcr.microsoft.com/dotnet/aspnet:8.0@sha256:6d40ae71165cb8a4427477ae3b447b05c080330cabae08b  0.0s
 => => resolve mcr.microsoft.com/dotnet/aspnet:8.0@sha256:6d40ae71165cb8a4427477ae3b447b05c080330cabae08b0dae6725  0.0s
 => [internal] load build context                                                                                  0.0s
 => => transferring context: 81.64kB                                                                               0.0s
 => CACHED [build 2/6] WORKDIR /src                                                                                0.0s
 => CACHED [build 3/6] COPY *.csproj .                                                                             0.0s
 => CACHED [build 4/6] RUN dotnet restore                                                                          0.0s
 => [build 5/6] COPY . .                                                                                           0.2s
 => [build 6/6] RUN dotnet publish -c Release -o /app /p:AssemblyName=Flowers.Api                                  3.6s
 => CACHED [stage-1 2/3] WORKDIR /app                                                                              0.0s
 => CACHED [stage-1 3/3] COPY --from=build /app .                                                                  0.0s
 => exporting to image                                                                                             0.1s
 => => exporting layers                                                                                            0.0s
 => => exporting manifest sha256:f378a4f70d93125862d7087709e7359b3fdafd125cc423f81d1b644521e5ab44                  0.0s
 => => exporting config sha256:e4f9d1bd8af13b0cefc4ce0f4529c3654ed884402f2dea620210068963e365f0                    0.0s
 => => exporting attestation manifest sha256:d7492a465a88be95bc6d0e168e53274a4cac7348755d6d93ebbde04c51a769a3      0.0s
 => => exporting manifest list sha256:54f39b05f5aa4e66271c46a28ee83390eed6b26410f6f2514360d4bb876bc5ce             0.0s
 => => naming to docker.io/library/flowers-api:latest                                                              0.0s
 => => unpacking to docker.io/library/flowers-api:latest                                                           0.0s

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/2is9h27afnvw5zm3r3t2cast3

7. Проверка flowers-api и вывод логов...
Pod запущен!

Логи flowers-api:
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished HTTP/1.1 GET http://10.1.2.96:8080/health - 200 - text/plain 5.4102ms
info: Microsoft.AspNetCore.Hosting.Diagnostics[1]
      Request starting HTTP/1.1 GET http://10.1.2.96:8080/health - - -
Received GET /health
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
      Executing endpoint 'Health checks'
info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
      Executed endpoint 'Health checks'
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished HTTP/1.1 GET http://10.1.2.96:8080/health - 200 - text/plain 6.2006ms
info: Microsoft.AspNetCore.Hosting.Diagnostics[1]
      Request starting HTTP/1.1 GET http://10.1.2.96:8080/health - - -                                                  Received GET /health                                                                                                    info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]                                                                      Executing endpoint 'Health checks'                                                                                info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
      Executed endpoint 'Health checks'
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished HTTP/1.1 GET http://10.1.2.96:8080/health - 200 - text/plain 6.5233ms
Предупреждение: API не отправил сообщение о старте приложения

8. Итоговый статус:
NAME                               READY   STATUS      RESTARTS   AGE
pod/db-migration-w4w57             0/1     Completed   0          11s
pod/flowers-api-685c495458-h2cd9   1/1     Running     0          51s
pod/postgresql-0                   1/1     Running     0          42s                                                                                                                                                                           NAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE                                      service/flowers-service   ClusterIP   10.109.214.35   <none>        80/TCP     51s                                      service/kubernetes        ClusterIP   10.96.0.1       <none>        443/TCP    2m53s
service/postgresql        ClusterIP   10.98.208.94    <none>        5432/TCP   42s
service/postgresql-hl     ClusterIP   None            <none>        5432/TCP   42s

NAME                                        CLASS   HOSTS           ADDRESS     PORTS   AGE
ingress.networking.k8s.io/flowers-ingress   nginx   arch.homework   localhost   80      50s

9. Проверка доступности API...
Выполняем тестовый запрос к API: http://arch.homework/
API успешно отвечает! Результат:
Flowers API is running                                                                                                                                                                                                                          Готово! Для ручной проверки выполните:                                                                                  curl http://arch.homework/                                                                                              или откройте в браузере: http://arch.homework/

11. Развертывание Prometheus
6e490f891e337e6ef507f82cf01b4907936e9aeb421aa42718e5682b550cb343
Prometheus успешно запущен

Проверка метрик Prometheus...
ПОДРОБНО: GET http://arch.homework:9090/metrics with 0-byte payload
ПОДРОБНО: received -1-byte response of content type text/plain; version=0.0.4; charset=utf-8; escaping=underscores
Метрики Prometheus доступны

12. Развертывание Grafana
164f7b6d12ae319cafa23d52fd6080a9f0209c898446bc5c50afe740a2d2d9a2
Grafana успешно запущена

13. Настройка сети monitoring
Контейнеры подключены к сети monitoring
Адрес Prometheus для Grafana: http://prometheus:9090

Проверка Grafana...
ПОДРОБНО: GET http://arch.homework:3000/ with 0-byte payload
ПОДРОБНО: GET http://arch.homework:3000/ with 0-byte payload
ПОДРОБНО: received -1-byte response of content type text/html; charset=UTF-8
Grafana доступна по адресу: http://arch.homework:3000
Логин/пароль по умолчанию: admin/admin

14. Инструментирование БД экспортером для prometheus
"prometheus-community" already exists with the same configuration, skipping
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "kong" chart repository
...Successfully got an update from the "ingress-nginx" chart repository
...Successfully got an update from the "prometheus-community" chart repository
...Successfully got an update from the "bitnami" chart repository
Update Complete. ⎈Happy Helming!⎈
NAME: prometheus-postgresql
LAST DEPLOYED: Sun Sep  7 20:11:14 2025
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l "app=prometheus-postgres-exporter,release=prometheus-postgresql" -o jsonpath="{.items[0].metadata.name}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl port-forward $POD_NAME 8080:9187 --namespace default
NAME                    URL
ingress-nginx           https://kubernetes.github.io/ingress-nginx
bitnami                 https://raw.githubusercontent.com/bitnami/charts/archive-full-index/bitnami
prometheus-community    https://prometheus-community.github.io/helm-charts
kong                    https://charts.konghq.com

15. Установка Kong API Gateway...
"kong" already exists with the same configuration, skipping
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "ingress-nginx" chart repository
...Successfully got an update from the "kong" chart repository
...Successfully got an update from the "prometheus-community" chart repository
...Successfully got an update from the "bitnami" chart repository
Update Complete. ⎈Happy Helming!⎈
namespace/kong created
Устанавливаем Kong Ingress Controller...
Release "kong" does not exist. Installing it now.
NAME: kong
LAST DEPLOYED: Sun Sep  7 20:11:24 2025
NAMESPACE: kong
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
To connect to Kong, please execute the following commands:
HOST=$(kubectl get nodes --namespace kong -o jsonpath='{.items[0].status.addresses[0].address}')
PORT=$(kubectl get svc --namespace kong kong-kong-proxy -o jsonpath='{.spec.ports[0].nodePort}')
export PROXY_IP=${HOST}:${PORT}
curl $PROXY_IP

Once installed, please follow along the getting started guide to start using
Kong: https://docs.konghq.com/kubernetes-ingress-controller/latest/guides/getting-started/
Ожидаем запуска Kong...
...Kong успешно запущен!

Получаем адрес Kong Gateway...
Kong NodePort: 31917
Настраиваем port forwarding для Kong...

Проверяем работу Kong Gateway через port forward...
✅ Kong Gateway работает и принимает запросы!
   Статус: 404 (Маршруты еще не настроены - это ожидаемо)
   Следующий шаг: Настройка маршрутов и сервисов для вашего API

Создаем тестовый маршрут для Kong...
ingress.networking.k8s.io/kong-test-route created

Текущее состояние сервисов:
NAME                           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                         AGE
kong-kong-admin                ClusterIP   10.111.98.227    <none>        8001/TCP,8444/TCP               19s
kong-kong-manager              NodePort    10.110.38.31     <none>        8002:32042/TCP,8445:30642/TCP   19s
kong-kong-metrics              ClusterIP   10.107.139.99    <none>        10255/TCP,10254/TCP             19s
kong-kong-proxy                NodePort    10.108.106.161   <none>        80:31917/TCP,443:32225/TCP      19s
kong-kong-validation-webhook   ClusterIP   10.102.151.208   <none>        443/TCP                         19s
NAME                         READY   STATUS    RESTARTS   AGE
kong-kong-86d8b55765-727rn   2/2     Running   0          19s
NAME              CLASS   HOSTS   ADDRESS   PORTS   AGE
kong-test-route   kong    *                 80      0s

Установка Kong завершена!
Kong API Gateway работает и готов
Доступ к Kong через port forward: http://localhost:8080
Тестовый URL: http://localhost:8080
Или прямой NodePort: http://localhost:31917
Следующие шаги:
1. Настройте маршруты для ваших сервисов
2. Настройте плагины аутентификации
3. Настройте SSL/TLS при необходимости

Port forward job работает в фоне. Для остановки используйте:
Stop-Job 3
Remove-Job 3
PS C:\Users\User\source\repos\Flowers\Flowers>"

=============================================================================================

План доработки кода:

"Создать Сервис Аутентификации: добавить в существующее ASP.NET Web.API:

POST /register - принятие логина/пароля, хеширование пароля (используйте BCrypt), сохранение в отдельную таблицу auth_users (user_id, login, password_hash).

POST /login - проверка логина/пароля, генерация JWT-токена. В токен нужно записать user_id и username.

Модифицировать Flowers API:

Добавить проверку заголовка Authorization и валидацию JWT-токена с помощью встроенного middleware.

Изменить логику методов GET /user/{id} и PUT /user/{id}: сравнивать user_id из токена с id из URL. Если не совпадают — возвращать 403 Forbidden.

Настроить Kong: Написать KongIngress или KongPlugin манифесты, которые будут маршрутизировать запросы:

/auth -> на сервис аутентификации.

/api -> на flowers-api.

Тесты Postman
Примерная структура тестового набора:

Переменные:

baseUrl: http://arch.homework

user1_token, user2_token

user1_id, user2_id

randomUsername, randomEmail (генерируются через pm.variables.set('randomUsername', 'user_' + Math.floor(Math.random() * 10000)); в Pre-request Script)

Сценарий:

Register User 1 (POST {{baseUrl}}/auth/register, body: {"username": "{{randomUsername}}", "password": "pass123", "email": "{{randomEmail}}"})

Login User 1 (POST {{baseUrl}}/auth/login, body: {"username": "{{randomUsername}}", "password": "pass123"}). В Tests скрипте: pm.variables.set('user1_token', pm.response.json().token);

Get Profile WITHOUT token -> 401 (GET {{baseUrl}}/api/user/profile, без заголовка -> должен быть 401)

Get Profile WITH token -> 200 (GET {{baseUrl}}/api/user/profile, с заголовком Authorization: Bearer {{user1_token}} -> 200)

Update Profile (PUT {{baseUrl}}/api/user/profile, с токеном, body: {"firstName": "NewName"})

Register and Login User 2 (Аналогично шагам 1 и 2, токен сохраняется в user2_token)

User2 tries to get User1 profile -> 403 (GET {{baseUrl}}/api/user/{{user1_id}}, с заголовком Authorization: Bearer {{user2_token}} -> 403 Forbidden)

Запуск из командной строки: newman run your-collection.json --global-var "baseUrl=http://arch.homework" -r cli"

=============================================================================================

Краткое описание шагов после установки Kong:

Настроить маршруты к вашему API - направить трафик через Kong на ваш flowers-api

Добавить аутентификацию - настроить JWT плагин для защиты API

Протестировать сценарии - регистрация, логин, доступ к профилю

🔧 Конкретные следующие шаги:
1. Создать Ingress для вашего API
Замените kong-test-route на маршрут к вашему сервису:

yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: flowers-api-route
  namespace: default  # или где у вас работает flowers-api
  annotations:
    konghq.com/strip-path: "true"
spec:
  ingressClassName: kong
  rules:
  - http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: flowers-api-service  # имя вашего сервиса
            port:
              number: 80  # порт вашего сервиса
2. Настроить JWT аутентификацию
Добавьте плагин аутентификации:

yaml
apiVersion: configuration.konghq.com/v1
kind: KongPlugin
metadata:
  name: jwt-auth
  namespace: default
plugin: jwt
3. Тестирование
Протестируйте работу через:

Port-forward: http://localhost:8080/api/user

Прямой доступ: http://localhost:32057/api/user

✅ Текущий статус:
Kong работает ✅

Port-forward настроен ✅

Базовый маршрут создан ✅

Готов к настройке бизнес-логики ✅

Можно переходить к настройке маршрутов для вашего Flowers API! 🚀